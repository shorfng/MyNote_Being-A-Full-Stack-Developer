> 当前位置：【Java】05_JavaWeb开源框架  -> 5.4_Mybatis 3



# 1、Mybatis的概述

## 1.1 对象/关系数据库映射（ORM） 

- ORM 全称 Object/Relation Mapping，表示对象-关系映射的缩写
- ORM 完成面向对象的编程语言到关系数据库的映射。当ORM框架完成映射后，程序员既可以利用面向
  对象程序设计语言的简单易用性，又可以利用关系数据库的技术优势。
- ORM把关系数据库包装成面向对象的模型。
- ORM框架是面向对象设计语言与关系数据库发展不同步时的中间解决方案。
- 采用ORM框架后，应用程序不再直接访问底层数据库，而是以面向对象的方式来操作持久化对象，而ORM框架则将这些面向对象的操作转换成底层SQL操作。
- ORM框架实现的效果：把对持久化对象的保存、修改、删除等操作，转换为对数据库的操作



## 1.2 Mybatis简介

- MyBatis是一款优秀的基于ORM的半自动轻量级持久层框架，它支持定制化SQL、存储过程以及高级映
  射。它对 JDBC 操作数据库的过程进行封装
- MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。
- MyBatis可以使用简单的XML或注解来配置和映射原生类型、接口和Java的POJO （Plain Old Java Objects，普通老式Java对 象）为数据库中的记录 
- Mybatis 通过 XML 或注解的方式将要执行的各种 statement（statement、preparedStatemnt、CallableStatement）配置起来，并通过 Java 对象和 statement中 的 SQL 进行映射生成最终执行的 SQL语句，最后由 Mybatis 框架执行 SQL 并将结果映射成 Java 对象并返回



## 1.3 MyBatis 发展历史

- MyBatis 本来是 apache 的一个开源项目 iBatis（iBATIS一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。iBATIS提供的持久层框架包括SQL Maps和Data Access Objects(DAO) ）
- 2010年6月这个项目由 apache software foundation 迁移到了google code，随着开发团队转投Google Code旗下，ibatis3.x正式更名为Mybatis
- 2013年11月代码迁移到 Github



## 1.4 MyBatis 优点

- Mybatis是一个半自动化的持久层框架，对开发人员开说，核心sql还是需要自己进行优化，sql和java编
  码进行分离，功能边界清晰，一个专注业务，一个专注数据 
- 使开发者只需要关注 SQL 本身，而不需要花费精力去处理 JDBC 繁杂的过程代码（如：注册驱动、创建connection、创建statement、手动设置参数、结果集检索等）

![1607046654655](image/0007.png)



## 1.5 MyBatis 源码下载与概览

  - 下载地址：https://github.com/mybatis/mybatis-3/releases
- 文件包说明

```java
lib文件夹：mybatis的依赖包所在
mybatis-xxx.jar：mybatis的核心包
mybatis-xxx.pdf：mybatis使用手册
```



## 1.6【区别】Mybatis & Hibernate

| 区别     | Mybatis         | Hibernate |
| -------- | --------------- | --------- |
| 本质上   | 半自动          | 全自动    |
| 安全性   | 存在SQL注入问题 | 预编译    |
| 日志系统 |                 | √         |
| 移植性   |                 | √         |
| 灵活性   | √               |           |



  - 本质上

```java
- Hibernate是全自动：Hibernate可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构，从而自动生成SQL语句

- MyBatis是半自动：MyBatis仅有基本的字段映射，对象数据和对象实际关系仍然需要通过定制SQL语句来实现和管理

- 对数据库类型进行切换时，Hibernate的成本明显低于MyBatis
```




- 日志系统：Hibernate >> MyBatis

```java
- Hibernate拥有完整的日志系统（如：SQL记录、关系异常、优化警告、缓存提示、脏数据警告等）
- MyBatis则除了基本记录功能外，功能薄弱很多
```




- 移植性：Hibernate >> MyBatis

```java
- Hibernate通过它强大的映射结构和HQL语言，大大降低了对象与数据库（Oracle、MySQL等）的耦合性
- MyBatis由于需要手写SQL，因此与数据库的耦合性直接取决于程序员写SQL的方法，如果SQL不具通用性并且用了很多某些固定数据库特性的SQL语句，移植性也会随之降低很多，成本很高
```




- 灵活性：MyBatis >> Hibernate

```java
- SQL优化方面，MyBatis都是直接编写原生态SQL到 XML 里，可严格控制SQL执行性能，灵活度高，非常适合对关系数据模型要求不高的软件开发

- SQL优化方面，Hibernate的SQL很多都是自动生成的，无法直接维护
  - 在一些复杂的业务需求上，HQL也是有局限性的
  - Hibernate虽然也支持原生SQL，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便
```




- 安全性

```java
- Hibernate是预编译的
- MyBatis可能存在SQL注入问题
```



# 2、Mybatis的引入

## 2.1 分析JDBC操作问题 

```java
public static void main(String[] args) {
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    ResultSet resultSet = null;
  try {
    // 加载数据库驱动
    Class.forName("com.mysql.jdbc.Driver");
    
    // 通过驱动管理类获取数据库链接
    connection = DriverManager.getConnection("jdbc:mysql://localhost:3306/mybatis?characterEncoding=utf-8", "root", "root");
 
    // 定义sql语句？表示占位符
    String sql = "select * from user where username = ?";

    // 获取预处理statement
    preparedStatement = connection.prepareStatement(sql);

    // 设置参数，第一个参数为sql语句中参数的序号(从1开始)，第二个参数为设置的参数值
    preparedStatement.setString(1, "tom");

    // 向数据库发出sql执行查询，查询出结果集
    resultSet = preparedStatement.executeQuery();

    // 遍历查询结果集
    while (resultSet.next()) {
		int id = resultSet.getInt("id");
		String username = resultSet.getString("username");
		// 封装User
		user.setId(id);
		user.setUsername(username);
	}
		System.out.println(user);
    }
 }catch (Exception e) {
	e.printStackTrace();
 } finally {
	// 释放资源
	if (resultSet != null) {
		try {
			resultSet.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
	}
	
    if (preparedStatement != null) {
		try {
			preparedStatement.close();
		} catch (SQLException e) {
			e.printStackTrace();
		}
    }
}
```



## 2.2 Mybatis解决JDBC编程的问题

- 原生jdbc开发存在的问题如下

```java
（1）数据库连接创建、释放频繁造成系统资源浪费，从而影响系统性能
- 解决：使用数据库连接池初始化连接资源，在 SqlMapConfig.xml 中配置数据连接池，使用连接池管理数据库链接

（2） Sql语句在代码中硬编码，造成代码不易维护，实际应用中sql变化的可能较大，sql变动需要改变
java代码
- 解决：将SQL语句配置/抽取在 XXXXmapper.xml 文件中，从而与Java代码分离

（3）使用preparedStatement向占有位符号传参数存在硬编码，因为sql语句的where条件不一定，可能
多也可能少，修改sql还要修改代码，系统不易维护
- 原因：SQL 语句的 where 条件不一定，可能多也可能少，占位符需要和参数一一对应
- 解决：Mybatis自动将Java对象映射到SQL语句，通过 statement 中的parameterType定义输入参数类型


（4）对结果集解析存在硬编码（查询列名），sql变化导致解析代码变化，系统不易维护，如果能将数据库
记录封装成pojo对象解析比较方便
- 原因：SQL 变化导致解析代码变化，并且解析前需要遍历
- 解决：使用反射、内省等底层技术，自动将实体与表进行属性与字段的自动映射（Mybatis 自动将 SQL 执行结果映射到 Java对象，通过statement中的resultType定义输出结果类型）
```



## 2.3 自定义框架设计

- 使用端：提供核心配置文件

```java
sqlMapConfig.xml : 存放数据库配置信息，引入mapper.xml
Mapper.xml : 存放sql语句的配置文件信息（包含sql语句、参数类型、返回值类型）
```

- 框架端（本质是对JDBC代码进行封装）

```java
（1）读取配置文件
- 根据配置文件的路径，加载配置文件成字节输入流，存储在内存中

（2）创建javaBean（容器对象）存放对配置文件解析出来的内容
- 读取完成以后配置信息以流的形式存在，如果存放在内存中，不好操作，所以创建容器对象
- Configuration 核心配置类: 存放sqlMapConfig.xml解析出来的内容（包含数据库基本信息、Map<唯一标识，Mapper> ）
- 唯一标识：namespace + "." + id
- MappedStatement映射配置类：存放Mapper.xml解析出来的内容（包含sql语句、statement类型、输入参数java类型、输出参数java类型）

（3）解析配置文件
- 创建sqlSessionFactoryBuilder类  方法：sqlSessionFactory build(inputSteam in)：
- 使用dom4j解析配置文件，将解析出来的内容封装到Configuration和MappedStatement容器对象中
- 创建 SqlSessionFactory 对象，获取sqlSession接口的实现类实例对象（工厂模式）

（4）创建 SqlSessionFactory 接口及实现类DefaultSqlSessionFactory
- openSession（）方法用来生成sqlSession

（5）创建 SqlSession 接口及实现类 DefaultSession
- 定义对数据库的CRUD操作（封装JDBC完成对数据库表的查询操作）
    selectList(String statementId,Object param)：查询所有
    selectOne(String statementId,Object param)：查询单个
    update（）
    delete（）

（6）创建 Executor 接口及实现类 SimpleExecutor实现类
query（Configuration，MapperStatement,Object...params）：执行的就是JDBC代码


涉及到的设计模式：
Builder构建者设计模式、工厂模式、代理模式
```



## 2.4 自定义框架实现 



# 3、Mybatis的架构

##### 架构图

![img](https://img.mubu.com/document_image/d436ec04-42f2-4a74-8af1-01a0323da50d-780133.jpg)

- 架构详解

  - Mybatis的配置文件：SqlMapConfig.xml
    - 此文件作为mybatis的全局配置文件，配置了Mybatis的运行环境等信息
  - Mybatis的配置文件：mapper.xml
    - sql映射文件，文件中配置了操作数据库的sql语句，此文件需要在SqlMapConfig.xml中加载
  - SqlSessionFactory（会话工厂）
    - 通过Mybatis环境等配置信息构造SqlSessionFactory即会话工厂
  - SqlSession（会话）
    - 由会话工厂创建sqlSession即会话，操作数据库需要通过sqlSession进行
  - Executor（执行器）
    - Mybatis底层自定义了Executor执行器接口操作数据库
    - Executor接口有两个实现：一个是基本执行器、一个是缓存执行器
  - 输入映射
    - Mapped Statement对sql执行输入参数进行定义，包括HashMap、基本类型、pojo
    - Executor通过Mapped Statement在执行sql前将输入的java对象映射至sql中
    - 输入参数映射就是jdbc编程中对preparedStatement设置参数
  - MappedStatement
    - Mapped Statement也是Mybatis一个底层封装对象
    - 它包装了Mybatis配置信息及sql映射信息等
    - mapper.xml文件中一个sql对应一个Mapped Statement对象，sql的id即是Mapped statement的id
  - 输出映射
    - Mapped Statement对sql执行输出结果进行定义，包括HashMap、基本类型、pojo
    - Executor通过Mapped Statement在执行sql后将输出结果映射至java对象中
    - 输出结果映射过程相当于jdbc编程中对结果的解析处理过程



# Mybatis的框架搭建

##### 步骤1：配置文件 SqlMapConfig.xml

```xml
<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE configuration PUBLIC "-//mybatis.org//DTD Config 3.0//EN" "http://mybatis.org/dtd/mybatis-3-config.dtd">

<!-- SqlMapConfig.xml：Mybatis的核心配置文件详解 -->
<configuration>
    <!-- 1、属性配置：引入jdbc.properties -->
    <properties resource="jdbc.properties"/>

    <!-- 2、全局配置参数:配置一些改变运行时行为的信息 -->
    <settings>
        <setting name="" value=""/>
    </settings>

    <!-- 3、类型别名：包以其子包下所有类，头字母大小都行 -->
    <typeAliases>
        <!-- 方式1：单个别名定义 -->
        <typeAlias type="com.loto.mybatis.pojo.User" alias="User"/>

        <!-- 方式2：批量别名定义，扫描整个包下的类，别名为类名（大小写不敏感） -->
        <package name="com.loto.mybatis.pojo"/>
    </typeAliases>

    <!-- 4、类型处理器：将 sql 中返回的数据库类型转换为相应 Java 类型的处理器配置-->
    <typeHandlers>
        <!-- 方式1：配置package（mybatis会去配置的package扫描TypeHandler）-->
        <!-- <package name="com.loto.mybatis"/> -->

        <!-- 方式2 -->
        <!-- handler：直接配置要指定的TypeHandler -->
        <!-- javaType：配置java类型（如String）-->
        <!-- jdbcType：配置数据库基本数据类型（如varchar）-->
        <typeHandler javaType="" jdbcType="" handler=""/>
    </typeHandlers>

    <!-- 5、对象工厂：实例化目标类的工厂类配置-->
    <objectFactory type=""/>

    <!-- 6、插件：修改 MyBatis 的核心行为 -->
    <plugins>
        <plugin interceptor=""></plugin>
    </plugins>

    <!-- 7、环境集合属性对象：数据库环境信息的集合（和spring整合后environments配置将废除）-->
    <environments default="development">
        <!-- 环境子属性对象：数据库环境配置的详细配置 -->
        <environment id="development">
            <!-- 事务管理：指定 MyBatis 的事务管理器（采用JDBC）-->
            <transactionManager type="JDBC"/>

            <!-- 数据源：数据库连接池 -->
            <!-- type：指定数据源的连接类型（POOLED：mybatis的数据源）（JNDI：基于tomcat的数据源）-->
            <dataSource type="POOLED">
                <property name="driver" value="${jdbc.driver}"/>
                <property name="url" value="${jdbc.url}"/>
                <property name="username" value="${jdbc.username}"/>
                <property name="password" value="${jdbc.password}"/>
            </dataSource>
        </environment>
    </environments>

    <!-- 8、映射器：加载配置sql映射文件的位置（xxxxMapper.xml）-->
	<mappers>
		<!-- 方式1：注册指定包下的所有mapper接口（要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中）-->
		<package name="com.loto.mybatis.mapper"/>

		<!-- 方式2：使用mapper接口类路径（要求mapper接口名称和mapper映射文件名称相同，且放在同一个目录中）-->
		<!-- <mapper class="com.loto.mybatis.mapper" /> -->

		<!-- 方式3：使用相对于类路径的资源（不用保证同接口同包同名）-->
       <!-- <mapper resource="mapperxml/OrderMapper.xml" />
        <mapper resource="mapperxml/UserMapper.xml" />-->

		<!-- 方式4：url指定mapper的绝对路径（与实际开发不符，因此基本不用）-->
		<!-- <mapper url="" /> -->
	</mappers>
</configuration>

```

##### 步骤2：创建pojo类：xxx.java

##### 步骤3：配置sql映射文件：xxxMapper.xml

- \#{}代表占位符
  - sql语法：select * from user where id = ?
  - mybatis语法：select * from user where id = #{v}
- ${}代表字符串拼接
  - sql语法：select * from user where username like '%五%'
  - mybatis语法
    - select * from user where username like "%"#{haha}"%"   ->用#，{}中可以用任意字符
    - select * from user where username like "%${value}%"    ->用$，{}中必须用value
- 输入映射：parameterType
  - 传入简单类型
  - 传入pojo对象
  - 传入pojo包装对象
  - 包装类QueryVo.java
    - UserMapper.xml
    - UserMapper.java
    - sqlMapConfig2.xml
    - MybatisTest04_parameterType.java
- 输出映射
  - resultType
    - 输出简单类型
      - 需求：查询用户表数据条数
      - MybatisTest05_resultType.java
      - UserMapper.java
      - UserMapper.xml
      - sqlMapConfig2.xml
    - 输出pojo对象
    - 输出pojo列表
  - resultMap

##### 步骤4：加载映射文件

- 方法1：原始Dao开发
- 方法2：Mapper动态代理开发

##### 【区别】selectOne和selectList



# 动态SQL

- 需求1：根据性别和名字查询用户
  - 使用到的标签
    - sql片段
    - if标签
    - where标签
  - UserMapper.java
  - UserMapper.xml
  - sqlMapConfig2.xml
  - MybatisTest07_sql.java
- 需求2：根据多个id查询用户信息
  - 使用到的标签
    - sql片段
    - where标签
    - foreach标签
  - QueryVo.java
  - UserMapper.java
  - UserMapper.xml
  - sqlMapConfig2.xml
  - MybatisTest07_sql.java



# 关联查询

- 商品订单数据模型

  - 图

    ![img](https://img.mubu.com/document_image/2f988375-c064-4a14-8429-2620aa646e5e-780133.jpg)

- 一对一查询

  - 需求：查询所有订单信息，关联查询下单用户信息
  - 方法1：使用resultType
  - 方法2：使用resultMap
    - Orders.java
    - OrderMapper.java
    - OrderMapper.xml
    - sqlMapConfig2.xml
    - MybatisTest08_relatedquery.java

- 一对多查询

  - 需求：查询所有用户信息及用户关联的订单信息
  - Orders.java
  - OrderMapper.java
  - OrderMapper.xml
  - sqlMapConfig2.xml
  - MybatisTest08_relatedquery.java



# Mybatis整合Spring

- 整合思想
  - SqlSessionFactory对象应该放到spring容器中作为单例存在
  - 传统dao的开发方式中，应该从spring容器中获得sqlsession对象
  - Mapper代理形式中，应该从spring容器中直接获得mapper的代理对象
  - 数据库的连接以及数据库连接池事务管理都交给spring容器来完成
- 整合jar包
  - Spring的jar包
  - Mybatis的jar包
  - Spring + Mybatis的整合包
  - Mysql的数据库驱动jar包
  - 数据库连接池的jar包
- 配置文件
  - log4j.properties
  - sqlMapConfig.xml
  - db.properties
  - applicationContext.xml
- Dao的开发
  - 方式1：原始Dao开发
  - 方式2：使用Mapper代理形式开发方式
    - 直接配置Mapper代理
    - 使用扫描包配置Mapper代理



# Mybatis逆向工程

- 使用步骤
  - 导入逆向工程到eclipse中
  - 修改配置文件generatorConfig.xml
    - 修改要生成的数据库表（17-19行）
    - 修改pojo文件所在包路径（29行）
    - 修改Mapper所在的包路径（38行、44行）
    - 总结：修改17行、29行、38行、44行、50行
  - 生成逆向工程代码：执行GeneratorSqlmap.java文件中的main函数
  - 刷新工程，得到逆向工程代码
  - 复制生成的代码到mybatis-spring工程
  - 修改applicationContext.xml配置文件
  - 单元测试
- 注意事项
  - 逆向工程生成的代码只能做单表查询
  - 不能在生成的代码上进行扩展，因为如果数据库变更，需要重新使用逆向工程生成代码，原来编写的代码就被覆盖了
  - 一张表会生成4个文件



# 分页插件：PageHelper

- PageHelper插件的简介
  - 支持Oracle、Mysql、MariaDB、SQLite、Hsqldb、PostgreSQL六种数据库分页
- PageHelper插件的使用方法
  - 步骤1：把PageHelper依赖的jar包添加到pom.xml中
    - 官方提供的代码对逆向工程支持的不好，使用参考资料中的pagehelper-fix
    - 使用idea将pagehelper-fix项目打开，然后使用maven进行install
    - 完成后，pagehelper-3.4.2-fix.jar存到本地的maven仓库
    - 目录：/Users/td/Documents/Maven3.5.2/repository/com/github/pagehelper/pagehelper/3.4.2-fix/pagehelper-3.4.2-fix.jar
  - 步骤2：在Mybatis配置文件SqlMapConfig.xml中配置拦截器插件
    <!-- Mybatis分页插件：Pag6eHelper --><plugins><plugin interceptor="com.github.pagehelper.PageHelper"><property name="dialect" value="mysql"/> <!-- 设置数据库方言（类型）--></plugin></plugins>
  - 步骤3：在代码中使用



# 11、问题报错

##### 1、元素类型为 "mapper" 的内容必须匹配 "(cache-ref|cache|resultMap==*==|parameterMap==*==|sql==*==|insert==*==|update==*==|delete==*==|select==*==)+".“

- 分析原因：属性必须按顺序来写

- 解决方案：比如<select 属性>   </select >，其中的属性的顺序必须按照规定写









Mybatis提供的内置类型别名

- https://www.cnblogs.com/cainiao-Shun666/p/7909675.html?tdsourcetag=s_pcqq_aiomsg

- 基本类型

  |   别名   |  类型   |
  | :------: | :-----: |
  |  _byte   |  byte   |
  |  _long   |  long   |
  |  _short  |  short  |
  |   _int   |   int   |
  | _integer | integer |
  | _double  | double  |
  |  _float  |  float  |
  | _boolean | boolean |

- 常用包装类型

  |    别名    |  类型   |
  | :--------: | :-----: |
  |   string   |  byte   |
  |    byte    |  long   |
  |    long    |  short  |
  |   short    |   int   |
  |    int     | integer |
  |  _double   | double  |
  |   double   |  float  |
  |   float    | boolean |
  |  boolean   |         |
  |    date    |         |
  |   object   |         |
  | collection |         |
  |    list    |         |
  | arraylist  |         |
  |    map     |         |
  |  hashmap   |         |
  |  iterator  |         |
  |   array    |         |

  ![img](https://img.mubu.com/document_image/0dff69c7-4050-4cc8-9206-23ba960b0d91-780133.jpg)





参考文档

- https://blog.csdn.net/fageweiketang/article/details/80739589